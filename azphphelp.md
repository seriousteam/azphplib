#SASPHP Templates
[TOC]
##Блоки
Каждый блок в шаблоне заключается в маркеры `[[  ]]`. 
Если блок ещё не открыт маркером `[[`, то закрывающий маркер `]]` воспринимается всего лишь как текст. Аналогично, если блок ещё не закрыт маркером `]]`, то открывающий маркер `[[` тоже будет считаться текстом.
Если необходимо вывести текст `[[`, то его надо экранировать как `[-[`. Аналогично `]]` экранируется как `]-]`. `[-[` экранируется `[--[`, `]-]` экранируется `]--]` и т.д.

Шаблон на таблице, которая содержит 1 запись с пустыми полями
    
    <tr>
        <td>
            [[@tr $data : SELECT * FROM t1]]    
            [-[12345]] [[$data.a.f1~'[[654321]-]']]
        </td>
    </tr>
    
выведет

    [[12345]] [[123456]]

##Выбор расположения

     [[placement_selector item]]
     
В качестве `item` могут быть:

1. [Переменная](#переменные) `$var`
2. [Повторитель](#повторитель) `$var : SELECT_STATEMENT`

По умолчанию, `placement_selector` ставит `item` вместе с открывающейся скобкой `{` **вне тэга**, т.е. *перед* ближайшим слева выбранным открывающимся тэгом, а закрывающуюся скобку `}` ставит после соответствующего ему закрывающего тэга. Если нужно ставить `item` внутрь тега, смотри [здесь](#внутри-тэга) 

Тэги, участвующие в шаблоне, должны быть *сбалансированы*, иными словами каждому открывающемуся тэгу должен соответствовать один закрывающийся. При соблюдении данного условия, шаблонизатор будет правильно высчитывать закрывающийся тэг.

###Конкретный тэг

    [[@tag_name item]]
    
Для расположения `item` выбирается ближайший слева тэг с именем `<tag_name>`.

    <tr>
        <td>[[@tr $record : SELECT_STATEMENT]]text</td>
    </tr>
    
даст

    foreach(...) {
    <tr>
        <td>text</td>
    </tr>
    }
    
###Ближайший тэг

    [[@* item]]
    
Для расположения `item` выбирается ближайший слева тэг с произвольным.

    <div>
        <span>
            [[@* $var : SELECT_STATEMENT]]
            <pre>text</pre>
        </span>
    </div>
    
даст

    <div>
        foreach(...) {
        <span>
            <pre>text</pre>
        </span>
        }
    </div>

###Внутри тэга
Чтобы поставить `item` внутрь выбранного тэга, нужно поставить `.` после [`placement_selector`](#выбор-расположения)

    [[@tag_name. item]]

или

    [[@*. item]]
     
Такая конструкция поставит `item` и `{` *после* выбранного тэга, а `}` *перед* соответствующим ему закрывающим тэгом.
    
    <tr>
    [[@tr. $var : SELECT_STATEMENT]]
    <td>text</td>
    </tr>
даст

    <tr>
    foreach(...) {
    <td>text</td>
    }
    </tr>

###Текущая строка

    [[@ item]]

Поставит `item` и `{` в начале текущей строки и `}` в конце неё

    текст1;текст2;[[@ $var : SELECT_STATEMENT]]текст3;текст4

даст

    foreach(...) { текст1;текст2;текст3;текст4 }

###Как значение атрибута

    [[attribute_name@tag_name item]]

Устанавливает атрибуту `attribute_name` тэга [`tag_name`](#конкретный-тэг) значение `item`

##Повторитель

    [[placement_selector $repeater_context : SELECT_STATEMENT]]

Создаёт цикл по записям [`SELECT_STATEMENT`](#запрос), который открывается и закрывается в соответствии с правилами [`placement_selector`](#выбор-расположения), данные которого доступны из переменной [`$repeater_context`](#контекст-повторителя).
###Главный повторитель
Часто на странице шаблона можно встретить больше одного повторителя, которые записаны параллельно, без иерархии.  А страница должна иметь один главный повторитель, к которому, например, применяется общий фильтр `cmd`. Чтобы определить его, надо записать:

    `[[MAIN repeater_context]]`
где [`repeater_context`](#контекст-повторителя) это контекст нужного нам повторителя.

###Контекст повторителя

    [[@div $repeater_context : SELECT_STATEMENT]]

Контекстом запроса является [переменная](#переменные) `$repeater_context`, которая предоставляет доступ к данным результата запроса [`SELECT_STATEMENT`](#запрос). Имя `repeater_context` может быть произвольным.

Находясь внутри контекста, можно завести подконтекст с подзапросом вида 
    
    [[@tag $repeater_sub_context of $repeater_context : SUBSELECT_STATEMENT]]
    
где `$repeater_sub_context` -- это [переменная](#переменные), содержащая данные подзапроса [`SUBSELECT_STATEMENT`](#подзапрос).

Уровней вложенности подконтекстов может быть много.

###Данные контекста повторителя

####Простое поле
Доступ к полю запроса осуществяется через такую конструкцию:

    [[$repeater_context.a.field_name]]
    
где `a` -- [алиас](#алиас-таблицы) таблицы подзапроса, `$repeater_context` -- [контекст повторителя](#контекст-повторителя), `$repeater_context.a.field_name` -- [переменная](#переменные)
    
####Поле из под связи

Доступ к полю запроса, полученному из под цепочки связей, осуществяется через такую конструкцию:

    [[$repeater_context.a.relation1.relation2.field_name]]
    
где `a` -- [алиас](#алиас-таблицы) таблицы подзапроса, `$repeater_context` -- [контекст повторителя](#контекст-повторителя). `$repeater_context.a.relation1.relation2.field_name` -- [переменная](#переменные).

При реализации шаблона будут использованы данные по связям из модели, и будут сконструированы соответствующие цепочки `JOIN`-ов.

####Поле с алиасом
Доступ к полю, которое фигурирует в [SELECT_STATEMENT](#запрос) в виде [выражения](#выражение) осуществяется так:

     [[$repeater_context->my_field_alias]]

####Встроенное выражение

Выражение пишется в следующей форме:
    
    [[$repeater_context.{EXPR}]]
    
где `EXPR` -- это имя функции.
#####NPP
Выводит номер записи по порядку

    <div>[[@div $data : SELECT * FROM T1]]
    [[$var.a.field_name.{NPP}]]
    </div>

даст

    1
    2
    3

#####COUNT
Выводит количество записей

#####FIRST
Непустой, если [повторение](#повторитель) первое

#####SAMPLE
Принимает значение `sample`, если это *нулевое* повторение, т.е. если оно добавлено искусcтвенно с пустыми данными конструкцией `SAMPLE AND SELECT`: 
    
    [[@tr $data : SAMPLE AND SELECT.....]]

Она добавляет в результат запроса повторителя ещё одну запись, начиная повторения с этого *пустого* объекта. По тем же полям, что выдает `SELECT`, генерируются пустые строки, которые и являются данными для этой новой записи.

    <tr>
        <td>
        [[@tr $d : SAMPLE AND SELECT * FROM t]]
        [[s@tr $d.{SAMPLE}]]
        [[$d.a.name]]
        </td>
    </tr>
    
даст 

    <tr s=sample>
        <td></td>
    </tr>
    <tr s>
        <td>1</td>
    </tr>
    ...

#####CMD
    
##Переменные

Переменные в шаблонизаторе это всё, что начинается с `$`

1. [Контекст повторителя](#контекст-повторителя) `[[$context]]`
2. [Поля контекста повторителя](#данные-контекста-повторителя) `[[$context.a.field_name]]`, `[[$context->field_alias]]`
3. Пользовательские переменные `[[$custom_variable]]`

и т.п.

Вывод любой переменной может быть модифицирован как встроенными так и самописными функциями PHP.

    [[$var.a.field_name~function_name]]
    
    [[$x~function_name]]
    
    [[$z->x~function_name]]

Что касается самой функции `function_name`, то переменная передается её первым параметром, остальные параметры можно передать так:

    [[$var.a.field_name
    ~function_name($extra_parameter, $other_extra_parameter,...)
    ]]
    
что будет эквивалентно выводу результата

    function_name( $var.a.field_name, $extra_parameter, $other_extra_parameter,...)

###Цепочка функций
При этом, можно использовать вызов нескольких функций подряд, каждая последующая функция будет работать с результатом предыдущей

    [[$var.a.field_name~F1~F2~F3]]
    
что в сущности эквивалентно

    F3( F2( F1($var.a.field_name) ) )

###Сохранение в переменную

     [[$var.a.field_name~$my_result]]

или

    [[$var.a.field_name~F1~F2~F3~$my_result]]

Переменная `$my_result` может иметь любое имя, и должна стоять в конце блока со знаком `$`.

Использование переменной в дальнейшем происходит по её имени:

    [[$my_result]]
    
    [[$my_result~trimZ]]
    
    [[attribute@tag $my_result~'0']]
    
    [[$my_result['element']]]
    
    [[$my_result.x.z]]
    
    [[$my_result->r]]

###Отключение предупреждений PHP
Отключить любой *warning* можно с помощью символа `@` перед переменной. Часто это полезно для обращения к несуществующим членам массива или объекта.

    [[@$my_result['not-existing-key']]]

###Встроенные функции
####empty value
Заменит результат `null` или пустую строку на указанное выражение

    [[$variable~'value-for-null-or-empty-value']]
    
Это короткий вызов встроенной функции `NVL`

####trimZ

    [[$x~trimZ]]
    
Отрезает в конце текста нули с точкой

    $x = "1000.00000"
    
    [[$x~trimZ]]
    
в результате

    1000

####toTitle

    [[$x~toTitle]]
    
Сокращает слово до одной первой буквы, ставя в конце точку.

    $x = "Александр"
    
    [[$x~toTitle]]
    
в результате

    А.


###Самописные функции

При работе с переменными шаблона можно использовать любые функции и переменные, подключенные к файлу шаблона. Для этого сам текст функций и строки подключения библиотек нужно записать в блоке `PROLOG`

    [[PROLOG 
    require_once(__DIR__.'/..\..\..\az\server\php/kladr/kladrfuncs.php');
    $kladr_conn = get_connection('kl_kladr');
    function my_function($p) {
        return $p + 1;
    }
    ]]


##Запрос

    SELECT * FROM table1 WHERE id='1' GROUP BY id ORDER BY id 

###Поля

####Используемые поля

Поля в `SELECT` определяются *автоматически*. Поэтому мы должны писать`*` в `SELECT * FROM ...`, поскольку вместо `*` шаблонизатор подставляет все используемые в выводе поля, в результате которого получится запрос вида  `SELECT a.f1, a.f2 FROM ...`.

####Дополнительные поля

Дополнительные поля, в том числе выражения, можно приписать после `*` через запятую. `SELECT *, COUNT(f1), f2, f3 FROM table1`

###WHERE

    SELECT * FROM T1 WHERE 
        field_name IS NOT NULL 
            AND 
        a.relations.paths.field_under_relation = other_field

В выражении для `WHERE` допустимо использование обычных полей `field_name` без указания [алиаса](#алиас-таблицы) (при реализации шаблона автоматически подставится нужный [алиас](#алиас-таблицы))
Также допустимо использование [полей из-под связи](#поле-из-под-связи) в виде `a.relations.paths.field_under_relation`(указание [алиаса](#алиас-таблицы) обязательно). 

###GROUP BY

###ORDER BY

###Алиас таблицы
По умолчанию главной таблице запроса присваивается алиас `a`, который вы должны использовать для [доступа к данным](#поля-повторителя) запроса.
###Выражение
Вы можете использовать любое SQL выражение как [дополнительное поле](#дополнительные-поля), указав для него свой алиас

    SELECT *, 
    MAX(f1) AS my_alias, 
    COUNT(*) AS my_count, 
    (SELECT name FROM T2 WHERE id='1' ) AS my_subselected_item 
    FROM T1

Для доступа к таким полям надо использовать [специальную конструкцию](#поле-с-алиасом).

###Подзапрос
Подзапрос пишется также, как и запрос, учитывая, что доступ к полям запроса выше уровнем осуществляется через специальный алиас `ext`.

    <tr>
        <td>
            [[@tr $x : SELECT * FROM t1]]
            [[@td $y of $x: SELECT * 
                    FROM t2 
                    WHERE 
                    a.f1 IS NOT NULL
                    AND a.f2 = ext.id
        	    ]]
    	</td>
	</tr>
###IN SELECT

Специльная конструкция вида 

    ...f1 IN (
        SELECT id FROM table2 WHERE id IN (
            SELECT id FROM table3 WHERE f1=f2
        )
    )
    
не является подзапросом в терминах шаблонизатора, потому воспринимается как чистое SQL-выражение. 

##Специальные блоки
###Метод экранирования
    
    [[ESC screen_method]]

где `screen_method` может принимать значения либо `html` либо `js` для javascript. По умолчанию используется метод экранирования `html`.

    <div>
        <span onclick="[[ESC js]]print('[[$data.a.f1]]')"[[ESC html]]></span>
    </div>
###Постраничный вывод

    [[PAGE BY number_of_records_on_page]]

Модифицирует повторитель, в содержимом которого он находится. Выводит цикл порциями по `number_of_records_on_page`    
    
##MathJax
 
You can render $\LaTeX{}$ mathematical expressions using **MathJax**, as on [math.stackexchange.com][1]:

The *Gamma function* satisfying $\Gamma(n) = (n-1)!\quad\forall
n\in\mathbb N$ is via the Euler integral

$$
\Gamma(z) = \int_0^\infty t^{z-1}e^{-t}dt\,.
$$
